{"version":"1","records":[{"hierarchy":{"lvl1":"223 Overview"},"type":"lvl1","url":"/overview","position":0},{"hierarchy":{"lvl1":"223 Overview"},"content":"This standard allows users to create semantic models that describe the many entities in their buildings that are relevant to advanced features and applications such as fault detection and diagnostics, demand flexibility, and real time optimization.\n\nThere is a huge amount of information about the many entities within a building that you may want to model. This section will explain what information you should represent in a 223 model and the 223 modeling constructs you will use to do so. Descriptions assume you have some familiarity with RDF graph data and know the \n\ndefinitions of key terms used in this section.","type":"content","url":"/overview","position":1},{"hierarchy":{"lvl1":"223 Overview","lvl2":"Type"},"type":"lvl2","url":"/overview#type","position":2},{"hierarchy":{"lvl1":"223 Overview","lvl2":"Type"},"content":"This standard provides well defined classes used to describe entities relevant to building system information. Entities in 223 models will generally be instances of the many classes defined or referred to by the standard. The classes in the standard provide ‘names’ for the fundamental building blocks used in 223 models (e.g. a fan will be an instance of the class \n\ns223:Fan) and also have rules defining how they are used (e.g. a fan must convey air).","type":"content","url":"/overview#type","position":3},{"hierarchy":{"lvl1":"223 Overview","lvl2":"Topology"},"type":"lvl2","url":"/overview#topology","position":4},{"hierarchy":{"lvl1":"223 Overview","lvl2":"Topology"},"content":"This standard can be used to describe the topology of the equipment and spaces in a building, but not the geometric details. Topology refers to the way entities are connected and how some media (e.g. water, air, or electricity) is conveyed between them. There are several different classes used to describe which entities participate in connections and how they connect: \n\nConnectables, which include the entities that are capable of connecting to each other; \n\nConnectionPoints, which model where Connectables can be connected; and \n\nConnections, which describe physical things through which the medium is conveyed, like pipes or ducts. These \n\nMediums (e.g. gas, electricity, water) are defined as an \n\nEnumerationKind in the standard. There are also multiple relations used to describe the details of these connections, and how the multiple entities involved in a connection relate to each other. Figure 1 summarizes these relations. Though there are many relations to describe different perspectives of a connection, only \n\ns223:cnx needs to be manually added to the model, and the rest can be automatically added to the model through the process of \n\ninference.\n\nFigure 1. Relations expressing different perspectives of connection","type":"content","url":"/overview#topology","position":5},{"hierarchy":{"lvl1":"223 Overview","lvl2":"Composition"},"type":"lvl2","url":"/overview#composition","position":6},{"hierarchy":{"lvl1":"223 Overview","lvl2":"Composition"},"content":"Composition is about what entities make up what other entities. For example, a piece of mechanical equipment like a VAV may in fact be made up of other pieces of mechanical equipment, such as a damper and a reheat coil. Additionally, a zone may be made up of several different spaces that receive a similar building service, or a floor may be made up of different rooms, corridors, or offices. Several different modeling constructs use the idea of composition. These modeling constructs include include \n\nEquipment, which may contain other equipment (e.g. VAV containing a Damper); \n\nZones, which may have \n\nDomainSpaces that receive a similar building service; \n\nZoneGroups, which group together similarly controlled Zones; \n\nSystems that represent a collection of interrelated Equipment; or \n\nPhysicalSpaces, which may contain other PhysicalSpaces as a floor contains multiple rooms. PhysicalSpaces may also enclose DomainSpaces, indicating that the DomainSpace is completely within the PhysicalSpace. For example, an auditorium (a PhysicalSpace) may enclose several different areas served by independently controlled lights (DomainSpaces).","type":"content","url":"/overview#composition","position":7},{"hierarchy":{"lvl1":"223 Overview","lvl2":"Telemetry"},"type":"lvl2","url":"/overview#telemetry","position":8},{"hierarchy":{"lvl1":"223 Overview","lvl2":"Telemetry"},"content":"A 223 model does not directly provide telemetric data about the real-time operation or past operation of the building systems.\nIt does provide information about the meaning or context of a given data point and it can link to a source of the data values so that an analytics application can find them.\nIf the building has a BACnet building automation and control system, the model can provide the necessary information for analytics or controls software to learn which BACnet object and BACnet property corresponds to the desired piece of information.\n\nIn 223, Properties are representations of some quality or characteristic of the building which might be observable, quantifiable, and/or actuatable.\nProperties may have an external reference which indicates where the information (i.e., data) corresponding to that property may be found -- this is commonly a BACnet object, but other types of external references are possible.\nThere are multiple types of \n\nProperties, such as control points that can be written to (\n\nActuatableProperties), sensor points that are observed (\n\nObservableProperties), either of which can refer to enumerated (\n\nEnumerableProperty) or quantified (\n\nQuantifiableProperty) values. Properties may also be used for mathematical operations, including those that are common in a building such as control logic. This idea is represented using \n\nFunctionBlocks. Properties also have many different characteristics which are described by a vocabulary of \n\nEnumerationKinds.\n\nUnlike other ontologies like \n\nSSN/SOSA, Properties are not associated with the inherent phenomena.\nIn 223, Properties are associated with a single sensor or actuator.\nThink of 223’s Properties as the source of the measurement or value which eventually becomes exposed in the building management system as a “Point”.","type":"content","url":"/overview#telemetry","position":9},{"hierarchy":{"lvl1":"223 Overview","lvl2":"Characteristics"},"type":"lvl2","url":"/overview#characteristics","position":10},{"hierarchy":{"lvl1":"223 Overview","lvl2":"Characteristics"},"content":"A model can also describe the characteristics of the entities in a building. These characteristics express details about entities that are not otherwise expressed by the type, topology, or composition of the entity. Often, these characteristics are linked to specific instances in a model. For example, a characteristic of a pump would be its rated flow. Another pump in the same 223 model may have a different rated flow, but it will use the same 223 class (i.e. \n\ns223:Pump). These types of characteristics are modeled using \n\nProperties.\n\nProperties also have various characteristics including their units, quantity kinds, enumeration kinds, and aspects. \n\nUnits describe the unit (e.g. Fahrenheit) of a \n\nQuantifiableProperty and \n\nquantity kinds describe the type of quantity that may be stated by means of units (e.g. temperature). These are modeled using \n\nqudt ontologies. \n\nEnumerableProperties do not have units, but they have enumerated values that can be described by \n\nEnumerationKinds. Aspects establish the context of a Property. For example, if a Property has a Temperature value of 80.6, aspects are used to state what that represents, such as a Temperature limit during working hours, etc. A Property can have any number of aspects, as needed to establish the context. Any \n\nEnumerationKind can be used as an aspect.","type":"content","url":"/overview#characteristics","position":11},{"hierarchy":{"lvl1":"Closed World Assumption"},"type":"lvl1","url":"/closed-world-assumption","position":0},{"hierarchy":{"lvl1":"Closed World Assumption"},"content":"The 223 standard adopts a closed world assumption, which is believed by many to be more appropriate in an industrial or commercial application. Under this assumption, it becomes possible to reason about the absence of a piece of information. Accordingly, the 223 standard constrains the use of relations to those specifically declared as appropriate for any given class.\n\nThe validation rule to enforce this informational constraint applies only to instances of s223: classes that use an s223: or qudt: property that lacks a relevant SHACL shape.\nTherefore, using a property with a namespace other than s223: or qudt: will not be flagged by the validation rule. A modeler is free to attach relations defined in other ontologies such as Brick, etc., assuming your application\nimports the necessary definitions, or at least declares the non-s223 properties that are used.\n\nDeclaring these additional imports or explicitly declaring your non-s223 properties advertises to other parties how your applications deviate from strict conformance to s223, helping with interoperability issues.","type":"content","url":"/closed-world-assumption","position":1},{"hierarchy":{"lvl1":"Definitions and Concepts"},"type":"lvl1","url":"/definitions","position":0},{"hierarchy":{"lvl1":"Definitions and Concepts"},"content":"To understand the explanations in this chapter it is important to know the defintions of several concepts. More can be learned about these concepts from the resources linked in the \n\nreference section.","type":"content","url":"/definitions","position":1},{"hierarchy":{"lvl1":"Definitions and Concepts","lvl2":"Graph Data Concepts"},"type":"lvl2","url":"/definitions#graph-data-concepts","position":2},{"hierarchy":{"lvl1":"Definitions and Concepts","lvl2":"Graph Data Concepts"},"content":"Entity: An entity is an abstraction of the actual “things” in a building. For example, mechanical equipment such as air handling units, luminaires, spatial elements like rooms, the area of these rooms served by certain mechanical equipment, or the zones these areas may be grouped into based on how the equipment is controlled.\n\nClass: A named category with intensional meaning (a definition) used for grouping entities.\nClasses are organized into a hierarchy, and entities are an instance of a given class. Classes are defined using SHACL shapes ensuring that they are instantiated correctly.\n\nRelationship: Defines the nature of a link between two related entities.\nExamples of relationships are encapsulation (one entity is contained within another), sequence (one entity takes effect before another in some process) and instantiation (one entity’s type is given by another).\n\nRelation: A predicate (RDF property) used to describe a given relationship.\nExamples of a relation are the 223 relation s223:contains, which defines the relationship between two pieces of equipment in which one contains another.\n\nGraph: An abstract organizational data structure representing a set of entities (nodes) and relationships (edges) described in triple-structure. 223 models are represented by a directed, labeled graph, and use the RDF standard. We recommend reading the \n\nWikipedia page on the abstract graph data structure for more information.\n\nA 223 Model: A 223 model is a digital representation of a building in RDF graph structure that uses the 223 standard. This means that elements of the building are represented using the modeling constructs defined in the standard. The standard leverages semantic web technologies, allowing easy integration with other types of models based on RDF.","type":"content","url":"/definitions#graph-data-concepts","position":3},{"hierarchy":{"lvl1":"Definitions and Concepts","lvl2":"223 Top Level Classes"},"type":"lvl2","url":"/definitions#id-223-top-level-classes","position":4},{"hierarchy":{"lvl1":"Definitions and Concepts","lvl2":"223 Top Level Classes"},"content":"The 223 standard defines a hierarchy of classes used to define the entities within a buidling. This section provides a basic definition of the classes at the top level of the hierarchy to help users understand what the standard aims to represent, which is described in the \n\noverview.\n\nConnection: A modeling construct for representing a physical thing (e.g., pipe, duct, wire) that connects and conveys a medium between two Connectable things.\n\nConnectionPoint: An abstract modeling construct representing the point where one Connectable thing connects to another.\n\nDomain: A categorization of building service or specialization used to characterize equipment or spaces (e.g., HVAC, lighting, plumbing).\n\nConnectable: This is the top level entity that defines the classes that may be connected via ConnectionPoints and Connections. There are three major sub-classes of connectable\n\nDomainSpace: A portion or entirety of a PhysicalSpace associated with a Domain. Often a DomainSpace is served by a particular piece of equipment, like a single VAV Box, and thus they can be connected to equipment. Multiple DomainSpaces controlled similarly can be grouped together, forming a Zone.\n\nEquipment: A modeling construct used to represent a mechanical device designed to accomplish a specific task (e.g. pump, fan, heat exchanger, luminaire, temperature sensor, flow meter). Equipment may contain and connect to other equipment, allowing detailed modeling of mechanical systems. Certain pieces of equipment (i.e. Sensors, Actuators, Controllers) may have unique relationships to properties to define how they act on the properties of other entities.\n\nJunction: A Junction is a modeling construct used to represent important branching points within a Connection.\n\nPhysicalSpace: An architectural concept representing a room, floor, or any physical space in a building. These PhysicalSpaces (e.g. a floor) can contain other PhysicalSpaces (e.g. a room).\n\nSystem: A task-oriented collection of interacting or interrelated Equipment defined by the modeler.\n\nZone: A collection of DomainSpaces grouped together based on building services or controls.\n\nProperties: Properties often represent the actuation and measurement points within a buidling. They may be associated with real-time data. They also may define the attributes of other entities (e.g. Equipment, DomainSpaces, Zones). They can be further contextualized using enumerations.\n\nEnumerations: The standard uses enumerations to convey groups of useful values for describing attributes of Properties, Equipment, and other things in the model. For example, the enumeration Role-Cooling describes that the equipment in question provides cooling.\n\nFunctionBlock: Is used to model transfer and/or transformation of information (e.g. control algorithms). It has relations to input properties and output properties, that represent input and output data. The actual algorithms that perform the transformations are not described in 223, and can be described using standard 231.","type":"content","url":"/definitions#id-223-top-level-classes","position":5},{"hierarchy":{"lvl1":"223 Graph Structure"},"type":"lvl1","url":"/graph-structure","position":0},{"hierarchy":{"lvl1":"223 Graph Structure"},"content":"","type":"content","url":"/graph-structure","position":1},{"hierarchy":{"lvl1":"223 Graph Structure"},"type":"lvl1","url":"/graph-structure#id-223-graph-structure","position":2},{"hierarchy":{"lvl1":"223 Graph Structure"},"content":"Standard 223 is represented using the Resource Description Framework (RDF). RDF is a general method for representic semantic information in the form of a triple, which consists of a subject, a predicate, and an object. The subject and object define two entities, which are a instances of some class, and the predicate defines how they are related. A collection of these triples make up a graph. The 223 standard defines classes and relationships relevant to the building space that can then be used to build a multi-graph representing a specific building or group of buildings. For more information about RDF and the other semantic technologies used by the standard, please look at the \n\nreference section.\n\nTo create a semantic model of your building using the 223 standard, you create instances that represent the entities in your building, and define them using the classes and relationships defined or referenced by the standard. For example, you may be creating a model of a building in which the air handling unit (ahu-1) contains a fan (fan-1). Your air handling unit (ahu-1) would be modeled as an instance of the 223 class \n\ns223:AirHandlingUnit, which describes the general class of things resembling Air Handling Units. Similarly, your fan (fan-1) would be an instance of the 223 class \n\ns223:Fan. The idea of containment is defined using the 223 relation \n\ns223:contains, so your air handling unit would relate to your fan using the relation s223:contains. The relationship between an instance and a class is defined using the RDF relation rdf:type, so your ahu and fan would relate to s223:AirHandlingUnit and s223:Fan using that relation. This example is shown in Figure 1.\n\nFigure 1. 223 Modeling Example","type":"content","url":"/graph-structure#id-223-graph-structure","position":3},{"hierarchy":{"lvl1":"Heat Transfer Equipment"},"type":"lvl1","url":"/heat-transfer-equipment","position":0},{"hierarchy":{"lvl1":"Heat Transfer Equipment"},"content":"A variety of Equipment subclasses are defined in the 223 standard. The names of the classes are\nintended to align with common names in the field as much as possible, but the technical distinctions\namong them are defined in terms of the constraints they must satisfy. These constraints primarily\nconcern the patterns of allowed ConnectionPoints, both in terms of the Medium flowing and in terms of\nthe directionality and number of ConnectionPoints. A diagram summarizing all Equipment subclasses that\nare involved in the transfer of heat is shown below. Note that instances of all of the classes shown\nwill have a role of s223:Role-HeatTransfer in addition to other possible roles. s223:Role-HeatTransfer is added\nautomatically using an inference rule.\n\nWhile the constraints indicated in the figure are the defining characteristics of each of the classes,\nit is easier to see how they are used by consulting the second figure that shows examples of\nequipment commonly found in the field.\n\nThe figure below shows a ground loop from \n\nNIST Example Building 1 Model 1. The ground loop is modeled as\na s223:Coil matching Pattern 2 of the constraints listed in the first figure above.","type":"content","url":"/heat-transfer-equipment","position":1},{"hierarchy":{"lvl1":"Medium Mixtures"},"type":"lvl1","url":"/medium-mixtures","position":0},{"hierarchy":{"lvl1":"Medium Mixtures"},"content":"The 223 standard includes a large set of enumerations, defined as a hierarchy of subclasses under the class s223:EnumerationKind.\nOne important piece of this hierarchy is the class s223:EnumerationKind-Substance and its direct subclass s223:Substance-Medium.\nIt is this branch of the hierarchy where you can find what you would expect to be flowing in a building, such as water, air and electricity. It is important to understand how a medium is modeled, especially when that medium is a mixture. The diagram below sketches the structure of the hierarchy. The names of the classes are abbreviated for clarity, so s223:Substance-Medium is shown as Medium for example. In the standard, each of the names follows the hyphenated naming convention of <parent class>-<local class>.\n\nNote in the figure that there is a division of the Medium class into Mix and Constituent. The Mix class is further divided into Fluid and Power&Signal. Fluid means what you might think - a liquid or gas that typically flows inside some sort of conduit like a duct or a pipe. You can find Water and Air here. To capture the description of what is in a mixture, the model contains the class Constituent and its subclasses. These subclasses are intended to identify the constituents of a mixture. So, for example, a water-glycol mixture would be defined as s223:Water-GlycolSolution, with two Properties via the relation s223:composedOf. Each of these Properties has a relation s223:ofConstituent that identifies one of the constituents from the Medium-Constituent hierarchy. Each Property also captures any other defining information. This is illustrated in the following figure for a 30%  Water-Glycol mixture.\n\nMixtures (s223:Medium-Mix) and constituents (s223:Medium-Constituent) are modeled this way to allow for compatibility validation among ConnectionPoints and Connections. Two mediums are deemed compatible if they share at least one common constituent.","type":"content","url":"/medium-mixtures","position":1},{"hierarchy":{"lvl1":"Purpose and Scope"},"type":"lvl1","url":"/purpose-scope","position":0},{"hierarchy":{"lvl1":"Purpose and Scope"},"content":"The Purpose and Scope from from the current standard are provided below to introduce it to users. For more information about the standard, please see the published document .","type":"content","url":"/purpose-scope","position":1},{"hierarchy":{"lvl1":"Purpose and Scope","lvl2":"1. Purpose"},"type":"lvl2","url":"/purpose-scope#id-1-purpose","position":2},{"hierarchy":{"lvl1":"Purpose and Scope","lvl2":"1. Purpose"},"content":"The purpose of this standard is to define formal knowledge concepts and a methodology to apply them to create interoperable, machine-readable semantic frameworks for representing building automation and control data, and other building system information.","type":"content","url":"/purpose-scope#id-1-purpose","position":3},{"hierarchy":{"lvl1":"Purpose and Scope","lvl2":"2. Scope"},"type":"lvl2","url":"/purpose-scope#id-2-scope","position":4},{"hierarchy":{"lvl1":"Purpose and Scope","lvl2":"2. Scope"},"content":"This standard provides a comprehensive way to apply semantic formalisms to represent the context of building system data and relationships between the associated building mechanical system components so that software applications can find and understand the information in an automated way. It is intended to facilitate the development and implementation of building analytics tools and enterprise knowledge applications that can implement many building system functions, including:\n\nautomated fault detection and diagnostics\n\nbuilding system commissioning\n\ndigital twins\n\nreal time optimization\n\nsmart grid interactions\n\nTODO link to public review.","type":"content","url":"/purpose-scope#id-2-scope","position":5},{"hierarchy":{"lvl1":"Sensors and Properties"},"type":"lvl1","url":"/sensors-and-properties","position":0},{"hierarchy":{"lvl1":"Sensors and Properties"},"content":"The 223 standard defines a variety of specialized sensors defined as a hierarchy of subclasses under the class s223:Sensor. This explanation section discusses some common relationships among sensors, and between sensors and properties.","type":"content","url":"/sensors-and-properties","position":1},{"hierarchy":{"lvl1":"Sensors and Properties","lvl2":"Sensors versus Sensor Platforms"},"type":"lvl2","url":"/sensors-and-properties#sensors-versus-sensor-platforms","position":2},{"hierarchy":{"lvl1":"Sensors and Properties","lvl2":"Sensors versus Sensor Platforms"},"content":"The standard constrains an instance of a Sensor to observe a single s223:ObservableProperty. Usually it is an instance of the subclass s223:QuantifiableObservableProperty that has a numerical value, but some sensors do generate non-numerical values such as alarms or presence, in which case the property is an instance of s223:EnumeratedObservableProperty.\n\nEquipment that observes multiple kinds of properties, say temperature and humidity, is modeled as an instance of s223:Equipment that contains (s223:contains) an instance of s223:TemperatureSensor and s223:HumiditySensor respectively.\n\nNote that if any of the sensors have s223:ConnectionPoints, the pattern described \n\nhere must also be followed. This might be the case for a flow sensor, for example.","type":"content","url":"/sensors-and-properties#sensors-versus-sensor-platforms","position":3},{"hierarchy":{"lvl1":"Sensors and Properties","lvl2":"Derived Properties"},"type":"lvl2","url":"/sensors-and-properties#derived-properties","position":4},{"hierarchy":{"lvl1":"Sensors and Properties","lvl2":"Derived Properties"},"content":"Another constraint in the 223 standard is that an s223:ObservableProperty must be associated with a s223:Sensor that observes a phenomenon and generates the value of the property. The sensor s223:observes the property.\n\nHow does one model a property that is not directly observed by a sensor? This is best modeled using a s223:Function that has one or more input properties (s223:hasInput) and one or more output properties (s223:hasOutput). The input properties may be directly observed by sensors, or may themselves be the outputs of other functions. The output property would be modeled as an instance of s223:QuantifiableProperty or s223:EnumerableProperty as appropriate, but it is not a s223:ObservableProperty.\n\nIn this way, a model may contain the computed temperature of a room based on some distant sensors and air flow rates for example.\n\nAn example is the psm:VAV1OutletTemperature property from the example model found \n\nhere.","type":"content","url":"/sensors-and-properties#derived-properties","position":5},{"hierarchy":{"lvl1":"Using 223 with Brick and RealEstateCore"},"type":"lvl1","url":"/brick-rec","position":0},{"hierarchy":{"lvl1":"Using 223 with Brick and RealEstateCore"},"content":"The \n\nBrick and \n\nRealEstateCore ontologies can be used to augment 223 models with a richer vocabulary of concepts, which offer the following benefits.\n\nThe Brick and RealEstateCore ontologies define a much larger set of concepts than 223, so using these ontologies can provide a 223 model with more specific and higher-level information helpful to consumers of the model\n\nThe governance structures of the Brick and RealEstateCore ontologies mean they can evolve much faster than 223 and thus standardize descriptions of new concepts, e.g. as new products emerge onto the market\n\nImportantly, a choice to model a building with 223 neither obviates nor requires the use of the Brick or RealEstateCore ontologies.\nThese can serve as another “layer” on top of the rich semantics provided by 223.","type":"content","url":"/brick-rec","position":1},{"hierarchy":{"lvl1":"Using 223 with Brick and RealEstateCore","lvl2":"Using Brick Points with 223"},"type":"lvl2","url":"/brick-rec#using-brick-points-with-223","position":2},{"hierarchy":{"lvl1":"Using 223 with Brick and RealEstateCore","lvl2":"Using Brick Points with 223"},"content":"Brick’s \n\nPoint class and its subclasses provide a large vocabulary of data sources (e.g., “Input/Output points”) within a building management system (BMS).\nThese can be used as annotations on 223 \n\nProperty instances.\n\nConsider the following (partial) 223 model with a Brick annotation:@prefix bldg: <urn:ex/> .\n@prefix s223: <http://data.ashrae.org/standard223#> .\n@prefix qudt: <http://qudt.org/schema/qudt/> .\n@prefix qudtqk: <http://qudt.org/vocab/quantitykind/> .\n@prefix unit: <http://qudt.org/vocab/unit/> .\n@prefix brick: <https://brickschema.org/schema/Brick#> .\n\nbldg:damper a s223:Damper ;\n    s223:cnx bldg:damper-out .\n\nbldg:sensor a s223:Sensor ;\n    s223:hasObservationLocation bldg:damper-out ;\n    s223:hasPhysicalLocation bldg:damper ;\n    s223:observes bldg:air-temp .\n\nbldg:damper-out a s223:OutletConnectionPoint ;\n    s223:cnx bldg:out-connection ;\n    s223:hasMedium s223:Medium-Air ;\n    s223:hasProperty bldg:air-temp .\n\nbldg:air-temp a s223:QuantifiableObservableProperty,\n                brick:Supply_Air_Temperature_Sensor ;\n    qudt:hasQuantityKind qudtqk:Temperature ;\n    s223:hasAspect s223:Role-Supply ;\n    qudt:hasUnit unit:DEG_C .\n\nBy stating that the bldg:air-temp entity is also a \n\nbrick:Supply_Air_Temperature_Sensor, Brick-based applications can more easily find the data they are looking for.\n223 requires multiple annotations be combined in order to model this concept.\n\nThe Brick class also clearly states the role of the entity.\nThe use of the QUDT annotations and Brick types means that this 223 model is also a valid Brick model!\n\nUsing Brick can simplify some queries against the model.\nFor example, finding the bldg:air-temp entity without Brick would require this query:PREFIX bldg: <urn:ex/>\nPREFIX s223: <http://data.ashrae.org/standard223#>\nPREFIX qudt: <http://qudt.org/schema/qudt/>\nPREFIX qudtqk: <http://qudt.org/vocab/quantitykind/>\nSELECT ?damper ?temp WHERE {\n    ?damper a s223:Damper ;\n        s223:hasProperty ?temp.\n    ?temp a s223:QuantifiableObservableProperty ;\n        qudt:hasQuantityKind qudtqk:Temperature ;\n        s223:hasAspect s223:Role-Supply .\n}\n\nWith Brick, the query above can be simplified to the following where the brick:hasPoint relationship is inferred automatically.PREFIX bldg: <urn:ex/>\nPREFIX s223: <http://data.ashrae.org/standard223#>\nPREFIX brick: <https://brickschema.org/schema/Brick#>\n\nSELECT ?damper ?temp WHERE {\n    ?damper a s223:Damper ;\n        brick:hasPoint ?temp .\n    ?temp a brick:Supply_Air_Temperature_Sensor .\n}","type":"content","url":"/brick-rec#using-brick-points-with-223","position":3},{"hierarchy":{"lvl1":"Using 223 with Brick and RealEstateCore","lvl2":"Using Brick Equipments with 223"},"type":"lvl2","url":"/brick-rec#using-brick-equipments-with-223","position":4},{"hierarchy":{"lvl1":"Using 223 with Brick and RealEstateCore","lvl2":"Using Brick Equipments with 223"},"content":"Brick’s extensive \n\nEquipment classes can also be used with 223.\nAny 223 \n\nEquipment can also be annotated with a Brick \n\nEquipment class as shown in the example below@prefix bldg: <urn:ex/> .\n@prefix s223: <http://data.ashrae.org/standard223#> .\n@prefix brick: <https://brickschema.org/schema/Brick#> .\n\nbldg:damper a s223:Damper, brick:Supply_Damper .","type":"content","url":"/brick-rec#using-brick-equipments-with-223","position":5},{"hierarchy":{"lvl1":"Using 223 with Brick and RealEstateCore","lvl2":"Using RealEstateCore Spaces with 223"},"type":"lvl2","url":"/brick-rec#using-realestatecore-spaces-with-223","position":6},{"hierarchy":{"lvl1":"Using 223 with Brick and RealEstateCore","lvl2":"Using RealEstateCore Spaces with 223"},"content":"RealEstateCore’s extensive \n\nSpace classes can also be used with 223 to provide human-facing annotations to 223 \n\nPhysicalSpace instances.\nSimply add the RealEstateCore space type as another type of the desired 223 \n\nPhysicalSpace entity.\nThis can provide a 223 model with much more descriptive and machine-readable information about the role and purpose of physical spaces in the model.\n\nConsider the following example:@prefix bldg: <urn:ex/> .\n@prefix s223: <http://data.ashrae.org/standard223#> .\n@prefix qudt: <http://qudt.org/schema/qudt/> .\n@prefix qudtqk: <http://qudt.org/vocab/quantitykind/> .\n@prefix unit: <http://qudt.org/vocab/unit/> .\n@prefix rec: <https://w3id.org/rec#> .\n\nbldg:my_space a s223:PhysicalSpace, rec:Kitchenette ;\n    s223:hasProperty bldg:temp .\n\nbldg:temp a s223:QuantifiableObservableProperty ;\n    qudt:hasQuantityKind qudtqk:Temperature ;\n    qudt:hasUnit unit:DEG_C .","type":"content","url":"/brick-rec#using-realestatecore-spaces-with-223","position":7},{"hierarchy":{"lvl1":"Modeling Design Patterns"},"type":"lvl1","url":"/design-patterns","position":0},{"hierarchy":{"lvl1":"Modeling Design Patterns"},"content":"Several modeling tools, such as BuildingMOTIF and Bob, enable modelers to easily reuse design patterns in their models. Both of these tools have pre-existing templates that allow developers to model at a higher level. However, buildings are unique, and developers may need to model pieces of equipment that are not already represented in 223P model creation tools. Thus, this guide provides a step-by-step way to model core ideas in the standard.","type":"content","url":"/design-patterns","position":1},{"hierarchy":{"lvl1":"Modeling Design Patterns","lvl2":"Topology"},"type":"lvl2","url":"/design-patterns#topology","position":2},{"hierarchy":{"lvl1":"Modeling Design Patterns","lvl2":"Topology"},"content":"This section guides developers on modeling connectivity and describing the topology between equipment. The topology diagram below illustrates various concepts and relations relevant to establishing connections. Building upon this general diagram, the following sections will detail incremental changes and provide examples to illustrate the progression of complexity. As shown in the topology diagram, predicates are defined at different levels of abstraction. This diagram demonstrates how various concepts in the standard describe connectivity between two Connectables. Some predicates are exclusive to connections between Connectable and ConnectionPoints, such as hasConnectionPoint, while others only apply between ConnectionPoints and Connections, like connectsAt. However, the generic “cnx” relation can describe connectivity between any concept involved, including Connectable, Connection, and ConnectionPoint. It’s crucial to note that all other predicates can be inferred from the “cnx” predicate.","type":"content","url":"/design-patterns#topology","position":3},{"hierarchy":{"lvl1":"Modeling Design Patterns","lvl2":"Minimum Connection Requirements for Equipment"},"type":"lvl2","url":"/design-patterns#minimum-connection-requirements-for-equipment","position":4},{"hierarchy":{"lvl1":"Modeling Design Patterns","lvl2":"Minimum Connection Requirements for Equipment"},"content":"In this example, we demonstrate a straightforward use case: creating the initial element of a connection. This involves attaching the Connectable (Equipment) “A9.return-fan” to its inlet and outlet ConnectionPoints using the “cnx” relation.","type":"content","url":"/design-patterns#minimum-connection-requirements-for-equipment","position":5},{"hierarchy":{"lvl1":"Modeling Design Patterns","lvl2":"Introducing cnx"},"type":"lvl2","url":"/design-patterns#introducing-cnx","position":6},{"hierarchy":{"lvl1":"Modeling Design Patterns","lvl2":"Introducing cnx"},"content":"The following scenario illustrates the connectivity between the equipment “A-9.return-fan” and “A-9.exhaust_air_damper.” The “cnx” sequence originates from the equipment “A-9.return-fan,” extends to its outlet connection point “A9.return-fan.airOutlet,” and connects to the Connection “A-9.return-air” between the two pieces of equipment. It then continues to the neighboring equipment’s inlet connection point “A-9.exhaust_air_damper.airInlet” The inferred relation in this graph is “connectedTo,” which is a directional relation.","type":"content","url":"/design-patterns#introducing-cnx","position":7},{"hierarchy":{"lvl1":"Modeling Design Patterns","lvl2":"Inferred Relations"},"type":"lvl2","url":"/design-patterns#inferred-relations","position":8},{"hierarchy":{"lvl1":"Modeling Design Patterns","lvl2":"Inferred Relations"},"content":"This next scenario builds upon the previous one and provides additional details about the inferred relations between different instances in this example. For instance, the “hasConnectionPoint” relation between “A-9.return-fan” and “A-9.return-fan.airOutlet” has been inferred based on the “cnx” relation between them. Similarly, the “connectsAt” relation has been established between “A-9.return-air” and “A-9.exhaust_air_damper.airInlet” based on the “cnx” relation between these entities.","type":"content","url":"/design-patterns#inferred-relations","position":9},{"hierarchy":{"lvl1":"Modeling Design Patterns","lvl2":"Containment"},"type":"lvl2","url":"/design-patterns#containment","position":10},{"hierarchy":{"lvl1":"Modeling Design Patterns","lvl2":"Containment"},"content":"This example describes the notation of containment in the standard. VAVBox1 contains two pieces of equipment: VAVBox1HeatingCoil and VAVBox1MotorizedDamper. Note that these two pieces of equipment are internally connected (as shown by the vertical purple line between them). Also, their connection points map to the inlet and outlet connection points of their container (VAVBox1) using the relation ‘mapsTo.’ This indicates that any incoming connection flow to VAVBox1 will lead to the damper, and any outgoing one will stem from the heating coil.","type":"content","url":"/design-patterns#containment","position":11},{"hierarchy":{"lvl1":"Modeling Design Patterns","lvl2":"Using Functions"},"type":"lvl2","url":"/design-patterns#using-functions","position":12},{"hierarchy":{"lvl1":"Modeling Design Patterns","lvl2":"Using Functions"},"content":"The next three examples showcase how Functions, as logical constructs, are implemented in the standard. The following example demonstrates how a luminaire can be controlled based on motion occupancy sensing. The Function labeled LuminaireLogic takes motion as an input property and provides the LuminaireCommand Property as the output, referred to by the luminaire via commandedByProperty. DumbSwitch simply provides power to the circuit.","type":"content","url":"/design-patterns#using-functions","position":13},{"hierarchy":{"lvl1":"Modeling Design Patterns","lvl2":"A Function with Multiple Inputs"},"type":"lvl2","url":"/design-patterns#a-function-with-multiple-inputs","position":14},{"hierarchy":{"lvl1":"Modeling Design Patterns","lvl2":"A Function with Multiple Inputs"},"content":"The next case examines a scenario where the luminaire logic encapsulated in Function1 takes a combination of inputs: the motion sensor property as before, and a UserSwitchProperty that is set by a smart switch. The function block uses this combination of inputs to determine whether the luminaire is turned on or off.","type":"content","url":"/design-patterns#a-function-with-multiple-inputs","position":15},{"hierarchy":{"lvl1":"Modeling Design Patterns","lvl2":"Modeling a Store-Bought Smart Switch"},"type":"lvl2","url":"/design-patterns#modeling-a-store-bought-smart-switch","position":16},{"hierarchy":{"lvl1":"Modeling Design Patterns","lvl2":"Modeling a Store-Bought Smart Switch"},"content":"Finally, the next case pulls the concepts of containment, connectivity and function together to model a motion-sensitive smart switch that a consumer might buy at a hardware store. The red rectangle delineates the consumer smart switch. The smart switch contains five elements:\n\na relay,\n\na light actuator that activates the relay based on the property LuminaireCommand,\n\nan occupant motion sensor that sets value of MotionProperty,\n\na controller that executes Function1 to set the value of the property LuminaireCommand,\n\nand a UserInputSwitch that sets the value of UserInputProperty.\n\nOn the left of the diagram, you can see the modeling of the electricity that flows from Breaker1, to Relay, then on to the Luminaire. At that point, the medium (not shown) changes from electricity to visible light that flows from the Luminaire, through OpticalPath, to DomainSpace.\n\nNote\n\nDon’t Panic If all this detail seems overwhelming, remember that you don’t need to model all the inner components of the smart switch if you don’t want to. The entire model inside the red rectangle can be modeled as simply as shown below.","type":"content","url":"/design-patterns#modeling-a-store-bought-smart-switch","position":17},{"hierarchy":{"lvl1":"Modeling Design Patterns","lvl2":"Branching Connections - Introducing Junction"},"type":"lvl2","url":"/design-patterns#branching-connections-introducing-junction","position":18},{"hierarchy":{"lvl1":"Modeling Design Patterns","lvl2":"Branching Connections - Introducing Junction"},"content":"There will be times when you want to model a Connection (such as an electric circuit) that does more than connect A to B - it will have branches. There are several ways to model such as Connection, depending on whether the location of, say, a meter requires you to show which branch it is on. First, here is a diagram of the simplest way to model a branched Connection, which just has multiple ConnectionPoints relating to the same Connection.\n\n\nIf you need to be able to talk about each branch specifically, you can split the Connection by using a Junction, as shown below. Here, there are 4 Connections - the initial circuit coming from the Breaker, and 3 branch circuits feeding the 3 Motors.\n\n\nNavigating the connectivity is of course different, but a SPARQL query such as the one below can use a transitive s223:cnx path to find all the instances of s223:Connectable (which includes Equipment and Junction) on the circuit.SELECT *\nWHERE {\npt7:Breaker s223:cnx* ?x .\n?x a/rdfs:subClassOf* s223:Connectable .\n}\n\n...which gives the following results:Simple case:\npt7:Breaker\npt7:Motor1\npt7:Motor2\npt7:Motor3\n\nSubstituting pt8:Breaker in the query gives:Case using a Junction:\npt8:Breaker\npt8:Junction\npt8:Motor1\npt8:Motor2\npt8:Motor3\n\nUsing a query such as this helps maintain interoperability when interpreting a file, regardless of the modeling approach used by the author.","type":"content","url":"/design-patterns#branching-connections-introducing-junction","position":19},{"hierarchy":{"lvl1":"Using 223 with QUDT"},"type":"lvl1","url":"/qudt","position":0},{"hierarchy":{"lvl1":"Using 223 with QUDT"},"content":"Because this standard includes references to measurements of physical properties, it is necessary to provide a model representation of units of measure as well as what those units are quantifying (e.g. temperature, power, etc.). This standard builds upon the “Quantities, Units, Dimensions and Types” (QUDT) ontology which is the leading open-source model of units and related concepts expressed in RDF/SHACL. The QUDT model is documented at the \n\nQUDT website. The key concepts used here are the classes Unit and QuantityKind. The 223 standard is compatible with Version 3.1.4 of QUDT and is expected to be compatible with\nall newer versions as well. It is a good idea to use the most recent version available.\n\nIf a user wants control over which version of QUDT is used, they can download any specific version at the\n\n\nQUDT Github Release page for use within their\napplication. For users who do not want to worry about the internal structure of the QUDT ontologies, the easiest way to bring in QUDT is to load the file QUDT-all-in-one-SHACL.ttl, included in Release 3.1.4 or later.\n\nThis is the recommended method because it ensures nothing changes without your knowledge. Alternatively, you can dynamically load the QUDT graphs into your application from the internet via the\ngraph URIs identified in the import statements of the 223 standard, such as \n\nhttp://​qudt​.org​/3​.1​.4​/QUDT​-all​-in​-one​-SHACL\nfor a specific version, or \n\nhttp://​qudt​.org​/QUDT​-all​-in​-one​-SHACL for the latest version.\n\nThe 223 standard contains an import statement to QUDT that looks like this:<http://data.ashrae.org/standard223/1.0/model/all>\n  a owl:Ontology ;\n  owl:imports <http://qudt.org/3.1.4/shacl/qudt-all> ;\n  .\n\nIt is important that the import statement points to the same version of QUDT that you download. If you want to just use the latest version, just replace the import triple with:owl:imports <http://qudt.org/shacl/qudt-all> ;\n\nFinally, a useful resource for a 223 modeler is the QUDT catalog found \n\nhere, where all the units, quantity kinds and other concepts are listed. Each concept is fully dereferenceable, so for example, the Ampere has the URI \n\nhttp://​qudt​.org​/vocab​/unit/A. Using content negotiation, this link resolves to an HTML page for a human reader, and to interpretable code for a machine.","type":"content","url":"/qudt","position":1},{"hierarchy":{"lvl1":"ASHRAE Standard 223 User Documentation "},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"ASHRAE Standard 223 User Documentation "},"content":"The purpose of this site is to provide documentation for users of the proposed ASHRAE Standard 223, Designation and Classification of Semantic Tags for Building Data.\n\nNote\n\nThis site is developed in conjunction with the ASHRAE Standard 223 project committee. However, it is not an official ASHRAE product or a part of the standard.\n\nImportant\n\nThe proposed standard is not yet available for public review.\n\nThe documentation uses Diataxis as a framework for its structure, which is organized into the following sections.","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"ASHRAE Standard 223 User Documentation ","lvl2":"Table of Contents"},"type":"lvl2","url":"/#table-of-contents","position":2},{"hierarchy":{"lvl1":"ASHRAE Standard 223 User Documentation ","lvl2":"Table of Contents"},"content":"ASHRAE Standard 223P User Documentation\n\nExplanation\n\nPurpose and Scope\n\nDefinitions and Concepts\n\n223 Overview\n\n223 Graph Structure\n\nClosed World Assumption\n\nHeat Transfer Equipment\n\nMedium Mixtures\n\nSensors and Properties\n\nTutorials\n\nModel Exploration\n\nModel Inference\n\nCreating a Model with BuildingMOTIF\n\nGuides\n\nModeling Design Patterns\n\nUsing 223 with QUDT\n\nUsing 223 with Brick and RealEstateCore\n\nReference\n\nOpen223 Resources\n\nOther Resources\n\nhttps://​diataxis​.fr/","type":"content","url":"/#table-of-contents","position":3},{"hierarchy":{"lvl1":"Open223 Resources"},"type":"lvl1","url":"/open223-resources","position":0},{"hierarchy":{"lvl1":"Open223 Resources"},"content":"The \n\nOpen223 GitHub organization was created in conjunction with the ASHRAE Standard 223 project committee to develop resources to support the use of Standard. However, it is not an official ASHRAE product or a part of the standard.","type":"content","url":"/open223-resources","position":1},{"hierarchy":{"lvl1":"Open223 Resources","lvl2":"Open223 Models"},"type":"lvl2","url":"/open223-resources#open223-models","position":2},{"hierarchy":{"lvl1":"Open223 Resources","lvl2":"Open223 Models"},"content":"This site contains the canonical sources for example models.\nEach page listed in the table of contents (on the left-hand side of the page) describes an example building or system modeled in 223.\nOn each page you will find the following:\n\nshort description of what is being modeled\n\nsupplementary materials and/or diagrams, where applicable\n\ndownload links for the model (both Turtle and JSON-LD are provided)\n\nlinks to example queries against the model; queries are hosted on Open223 Query (see link below)\n\na table of entities found inside the model","type":"content","url":"/open223-resources#open223-models","position":3},{"hierarchy":{"lvl1":"Open223 Resources","lvl2":"Open223 Explore"},"type":"lvl2","url":"/open223-resources#open223-explore","position":4},{"hierarchy":{"lvl1":"Open223 Resources","lvl2":"Open223 Explore"},"content":"This page hosts autogenerated documentation of the 223 ontology, emphasizing the availability and correct use of concepts and properties defined by the ontology.\nThe Explore tool divides the ontology up across four tabs.","type":"content","url":"/open223-resources#open223-explore","position":5},{"hierarchy":{"lvl1":"Open223 Resources","lvl3":"Classes","lvl2":"Open223 Explore"},"type":"lvl3","url":"/open223-resources#classes","position":6},{"hierarchy":{"lvl1":"Open223 Resources","lvl3":"Classes","lvl2":"Open223 Explore"},"content":"The classes tab organizes the classes of the standard based on their class hierarchy.\nOne can click on the class name to view a description of the class and its constraints, or click on the “+” to the left of the class name to view all the subclasses of that class.\nFor example, all 223 classes are a subclass of s223:Concept, and can be accessed by clicking the “+” to the left of “Concept”.\n\nThe Definition section describes what relations instances of the class must have.\nThe Properties section below lists all of the relation constraints the class as inherited, including: which of those relations are optional (marked with a ?), can happen 0 or more times (marked with a *), must happen\nat least once (marked with a +), or are necessary (no additional markings, like in the image above).\nAdditionally all links highlighted in yellow on a given class page can be used to navigate to a description of that class or property.\n\nThe definitions listed on the Explore tool are not definitive but instead capture common usage; refer to the standard for the full and complete definition.","type":"content","url":"/open223-resources#classes","position":7},{"hierarchy":{"lvl1":"Open223 Resources","lvl3":"Properties","lvl2":"Open223 Explore"},"type":"lvl3","url":"/open223-resources#properties","position":8},{"hierarchy":{"lvl1":"Open223 Resources","lvl3":"Properties","lvl2":"Open223 Explore"},"content":"The properties tab organizes the relations of the standard and its dependencies.\nClicking on a relation shows which classe are in the domain and range of the relation, if available.","type":"content","url":"/open223-resources#properties","position":9},{"hierarchy":{"lvl1":"Open223 Resources","lvl3":"Ontologies and Files","lvl2":"Open223 Explore"},"type":"lvl3","url":"/open223-resources#ontologies-and-files","position":10},{"hierarchy":{"lvl1":"Open223 Resources","lvl3":"Ontologies and Files","lvl2":"Open223 Explore"},"content":"These last two tabs list all properties, concepts, classes, etc defined in each ontology loaded into the tool.\nThis currently includes 223 as well as its dependencies (e.g., QUDT).","type":"content","url":"/open223-resources#ontologies-and-files","position":11},{"hierarchy":{"lvl1":"Open223 Resources","lvl2":"Open223 Query"},"type":"lvl2","url":"/open223-resources#open223-query","position":12},{"hierarchy":{"lvl1":"Open223 Resources","lvl2":"Open223 Query"},"content":"This page provides client-side SPARQL query processing using Oxigraph. It contains several example 223 models and several example queries.\nThere are three dropdowns in the top-left corner of the page:\n\nTwo of these determine which 223 model you want to query:\n\nYou can upload your own graph by choosing a local Turtle file to upload or by referencing one by URL on the web\n\nYou can select an example 223 model from the dropdown menu. Each of these models contains a copy of 223 and has had SHACL inference applied to it\n\nThe last dropdown contains a set of example queries against 223 models. Select a query from the dropdown to populate the query box.\nYou can also edit the query box directly to express a SPARQL query.\n\nClick the ▶️ in the query window to execute the query against the currently loaded model.\n\nThe results will be displayed below. Click a URL to get its properties and relations listed on the right-hand side of the screen.","type":"content","url":"/open223-resources#open223-query","position":13},{"hierarchy":{"lvl1":"Open223 Resources","lvl2":"Open223 Defs"},"type":"lvl2","url":"/open223-resources#open223-defs","position":14},{"hierarchy":{"lvl1":"Open223 Resources","lvl2":"Open223 Defs"},"content":"This page provides a set of \n\nconcise bounded descriptions (CBDs) of 223 concepts, rules, shapes, and entities with permalinks referenced by the 223 standard document.","type":"content","url":"/open223-resources#open223-defs","position":15},{"hierarchy":{"lvl1":"Other Resources"},"type":"lvl1","url":"/other-resources","position":0},{"hierarchy":{"lvl1":"Other Resources"},"content":"","type":"content","url":"/other-resources","position":1},{"hierarchy":{"lvl1":"Other Resources","lvl2":"Semantic Web Technologies"},"type":"lvl2","url":"/other-resources#semantic-web-technologies","position":2},{"hierarchy":{"lvl1":"Other Resources","lvl2":"Semantic Web Technologies"},"content":"ASHRAE 223P utilizes semantic information tools that provide explicit meaning to data to facilitate machine understanding and interaction. These Semantic Web technologies collectively empower the creation of machine-readable, interconnected, and interoperable data. By adopting RDF for data representation, SHACL for defining constraints, SPARQL for querying, and Turtle for human-friendly syntax, 223P enables automated understanding, integration, and analysis of information across diverse building systems. Each of these technologies are introduced below and described in greater depth in this section.","type":"content","url":"/other-resources#semantic-web-technologies","position":3},{"hierarchy":{"lvl1":"Other Resources","lvl3":"Resource Description Framework (RDF)","lvl2":"Semantic Web Technologies"},"type":"lvl3","url":"/other-resources#resource-description-framework-rdf","position":4},{"hierarchy":{"lvl1":"Other Resources","lvl3":"Resource Description Framework (RDF)","lvl2":"Semantic Web Technologies"},"content":"At the core of the Semantic Web is RDF, a standard for representing and exchanging data in a machine-readable format. RDF provides a simple, flexible model based on triples, where each triple consists of a subject, predicate, and object. This structure forms the foundation for expressing relationships and connections between resources on the web, creating a powerful graph-based data model.  This model allows us to define how different entities related to building systems (devices, data points, zones, ducts, etc) are related to each other. The subject and object define two entities and the predicate defines how they are related. For example, an air handling unit may contain a fan. This would be described in a 223P model as AHU (subject) contains (predicate) Fan (object) as shown in Figure 1. Please visit this \n\nRDF documentation for more information.\n\nFigure 2a. Triples as diagram\n\n- Mermaid is not fully supported by github pages and jupyterlab, but in the future it should be. We may be able to create figures like this\n```mermaid\n---\ntitle: Figure 1. Simple Triple\n---\ngraph LR\n    AHU-- contains - ->Fan\n``` -","type":"content","url":"/other-resources#resource-description-framework-rdf","position":5},{"hierarchy":{"lvl1":"Other Resources","lvl3":"Shapes Constraint Language (SHACL)","lvl2":"Semantic Web Technologies"},"type":"lvl3","url":"/other-resources#shapes-constraint-language-shacl","position":6},{"hierarchy":{"lvl1":"Other Resources","lvl3":"Shapes Constraint Language (SHACL)","lvl2":"Semantic Web Technologies"},"content":"SHACL is a language for describing and validating the structure and constraints of RDF graphs. It allows developers and data modelers to define rules, or “shapes,” that specify the expected structure and characteristics of RDF data. SHACL plays a critical role in ensuring data integrity, providing a means to express and enforce constraints on RDF graphs, which is particularly valuable in the context of semantic modeling for building systems and related data.\n\nRules used in 223P are split into two types: inference rules and validation rules. Validation ensures that information within the model conforms to rules in the standard by checking properties, types, value ranges, patterns, and other aspects of data nodes against specified criteria in the SHACL shapes. If a node in the RDF graph violates any of these constraints, it is flagged as non-compliant. Inference adds information to the graph when a rule’s conditions are met. These rules can add valuable information to a 223P model and make implicit relationships explicit.\n\nFor validation SHACL is used and for inference SHACL Advanced Features is used. To learn more about these technologies, please reference the \n\nSHACL documentation and the \n\nSHACL Advanced Features documentation.","type":"content","url":"/other-resources#shapes-constraint-language-shacl","position":7},{"hierarchy":{"lvl1":"Other Resources","lvl3":"SPARQL (SPARQL Protocol and RDF Query Language)","lvl2":"Semantic Web Technologies"},"type":"lvl3","url":"/other-resources#sparql-sparql-protocol-and-rdf-query-language","position":8},{"hierarchy":{"lvl1":"Other Resources","lvl3":"SPARQL (SPARQL Protocol and RDF Query Language)","lvl2":"Semantic Web Technologies"},"content":"SPARQL is a query language designed specifically for querying RDF data. It enables users to retrieve, manipulate, and analyze information stored in RDF graphs. SPARQL queries are expressive and powerful, allowing for the extraction of meaningful insights from complex and interconnected semantic data. SPARQL is widely used and supported by multiple platforms. To learn about SPARQL, we recommend looking at the \n\nSPARQL documentation.\n\nSPARQL is the primary way that users will query data from 223P models. \n\nQuery Open223 provides an easy webpage to run queries. \n\nReference on the use of this website are provided as well as \n\nexample models and queries that users can experiment with.","type":"content","url":"/other-resources#sparql-sparql-protocol-and-rdf-query-language","position":9},{"hierarchy":{"lvl1":"Other Resources","lvl4":"Querying Models","lvl3":"SPARQL (SPARQL Protocol and RDF Query Language)","lvl2":"Semantic Web Technologies"},"type":"lvl4","url":"/other-resources#querying-models","position":10},{"hierarchy":{"lvl1":"Other Resources","lvl4":"Querying Models","lvl3":"SPARQL (SPARQL Protocol and RDF Query Language)","lvl2":"Semantic Web Technologies"},"content":"SPARQL (SPARQL Protocol and RDF Query Language) querying is a fundamental aspect of interacting with RDF-based semantic models. SPARQL provides a powerful and expressive language for querying RDF data, enabling users to retrieve specific information from semantic graphs, insert data into graphs, or construct new graphs based on query results. With SPARQL, users can construct queries to search, filter, and extract data based on the defined relationships and properties within the RDF model. These queries can range from simple requests for specific data points to complex inquiries involving multiple patterns and conditions. It plays a key role in extracting meaningful data from 223P models. Several tools support the use of SPARQL queries to interrogate 223P models. RDFLib supports querying and is used both by BuildingMOTIF and Bob. TopBraid Composer and GraphDB both support SPARQL queries, and provide a graphical user interface for exploring semantic models.\n\nSPARQL querying basics: The SPARQL querying language is used in SHACL graphs. While SHACL graphs use multiple subject-predicate-object expressions to describe complex relationships. SPARQL is used to query specific information from those complex relationships of SHACL graphs. For example, SPARQL can retrieve SHACL subject-predicate-object expressions with a specific subject, a specific predicate, a specific object, or any combinations of subject, predicate, and object.\n\nIn the model usage section TODO ___ below, a tutorial shows how to run SPARQL competency questions on 223P models. Open223 provides these example models and queries, and also allows users to upload their own building models and write their own SPARQL queries for further testing.\n\nSeveral other query languages are often used for graph data models. These include the Cypher language employed by Neo4J and GraphQL. Unlike SPARQL, which is designed specifically for RDF, they can still be used on 223P models.\n\nIn example TODO ___ below, a tutorial","type":"content","url":"/other-resources#querying-models","position":11},{"hierarchy":{"lvl1":"Other Resources","lvl3":"Terse RDF Triple Language (Turtle - TTL)","lvl2":"Semantic Web Technologies"},"type":"lvl3","url":"/other-resources#terse-rdf-triple-language-turtle-ttl","position":12},{"hierarchy":{"lvl1":"Other Resources","lvl3":"Terse RDF Triple Language (Turtle - TTL)","lvl2":"Semantic Web Technologies"},"content":"Turtle is a textual syntax for expressing RDF data in a compact and human-readable format. It provides a way to represent RDF triples more concisely than XML-based alternatives. Turtle is widely used for writing and sharing RDF data, providing a clear and efficient means of communication in both development and deployment scenarios. For more about the ttl format, please reference the \n\nttl documentation.\n\nThe 223P ontology and various examples in this documentation use the ttl format to represent graph data. Graph data may also be provided in diagrams in this documentation. These diagrams should be read as a series of triples rather than as a flow chart. Figure 2 shows graph data both in ttl format and as a diagram, both of which you will encounter in this documentation.\n\nFigure 2a. Triples as diagram\n\n\n\nFigure 2b. Triples as TTL textual format@prefix ex: <urn:example/> .\n@prefix s223: <http://data.ashrae.org/standard223#> .\n\n    ex:AHU s223:contains ex:Fan .\n    ex:AHU s223:contains ex:HeatingCoil .\n    ex:Fan s223:connectedTo ex:HeatingCoil .","type":"content","url":"/other-resources#terse-rdf-triple-language-turtle-ttl","position":13},{"hierarchy":{"lvl1":"Other Resources","lvl2":"Tools for Working with ASHRAE 223P"},"type":"lvl2","url":"/other-resources#tools-for-working-with-ashrae-223p","position":14},{"hierarchy":{"lvl1":"Other Resources","lvl2":"Tools for Working with ASHRAE 223P"},"content":"The standard is built on Semantic Web technology, and there are many open-source and proprietary tools available to enable creation and validation of 223P models. A selection of several tools are as follows:\nBuildingMOTIF:\n\nSI-builder (Bob): This tool has been developed in Python and used in the development of the standard to simplify the creation of 223P building models. It uses an extensive class structure defining data points, equipment, and spaces in terms of 223P modeling constructs, and enables the creation of models using python scripts.\n\nRDFLib/PySHACL:  BuildingMOTIF and SI-builder provide user-friendly methods to build and validate 223P models. They both utilize the python libraries RDFLib and PySHACL. RDFLib is a Python library for working with RDF, and it provides functionalities for creating, parsing, querying, and manipulating RDF graphs. PySHACL is a Python library that provides implementation for SHACL validation and inference.\n\nTopBraid Composer:TopBraid Composer is a comprehensive Semantic Web modeling tool that supports the development and visualization of RDF-based ontologies and semantic models. It has been used in the development of the standard and offers both free and paid versions. It also provides an API for utilizing its SHACL validation, which is based on Apache Jena. Apache Jena also provides other tools for interacting with graph data\n\nGraphDB: GraphDB is a triplestore that provides storage and query capabilities for RDF data. It provides support for SPARQL querying as well as visualization and exploration of semantic models.\n\nNeo4J: TODO Should reach out to christian about that\n\npyVis: TODO What other visualization tools are available?\n\nThere are other tools available, but the above list may serve as a place to start.","type":"content","url":"/other-resources#tools-for-working-with-ashrae-223p","position":15},{"hierarchy":{"lvl1":"Other Resources","lvl2":"Using Model Building Tools"},"type":"lvl2","url":"/other-resources#builder-tools","position":16},{"hierarchy":{"lvl1":"Other Resources","lvl2":"Using Model Building Tools"},"content":"Link to Bob with description (and note that it’s not yet complete)\n\nLink to BMOTIF","type":"content","url":"/other-resources#builder-tools","position":17},{"hierarchy":{"lvl1":"Creating a Model with BuildingMOTIF"},"type":"lvl1","url":"/model-creation-buildingmotif","position":0},{"hierarchy":{"lvl1":"Creating a Model with BuildingMOTIF"},"content":"BuildingMOTIF is a Python SDK for creating, manipulating, and validating semantic building models.\nHere, we will demonstrate how to create a simple ASHRAE 223P model using BuildingMOTIF.\n\nWe will create a model that includes a simple HVAC system with a VAV terminal unit serving a zone.\nThis will use BuildingMOTIF \n\nTemplates, which are reusable components that encapsulate common patterns in building modeling.","type":"content","url":"/model-creation-buildingmotif","position":1},{"hierarchy":{"lvl1":"Creating a Model with BuildingMOTIF","lvl2":"Setting up BuildingMOTIF"},"type":"lvl2","url":"/model-creation-buildingmotif#setting-up-buildingmotif","position":2},{"hierarchy":{"lvl1":"Creating a Model with BuildingMOTIF","lvl2":"Setting up BuildingMOTIF"},"content":"Downloading the NREL 223P templates library\n\n!git clone --filter=blob:none --no-checkout https://github.com/NREL/BuildingMOTIF\n!pushd BuildingMOTIF && git sparse-checkout init --cone\n!pushd BuildingMOTIF && git sparse-checkout set libraries/ashrae/223p/nrel-templates\n!pushd BuildingMOTIF && git checkout\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe following code sets up a temporary (in-memory) BuildingMOTIF instance, loads the necessary libraries, and creates an (empty) model to hold our building data.\n\nfrom rdflib import Namespace\nfrom buildingmotif import BuildingMOTIF\nfrom buildingmotif.dataclasses import Library, Model\nfrom buildingmotif.model_builder import TemplateBuilderContext as ModelBuilder\nimport logging\n\n# Create a BuildingMOTIF object. If you do not have Java installed, remove the \"shacl_engine\" parameter\nbm = BuildingMOTIF('sqlite://', shacl_engine='topquadrant', log_level=logging.ERROR)\n\n# load 223P library and some dependencies. We will load a recent copy from the open223.info\ns223 = Library.load(ontology_graph=\"https://open223.info/223p.ttl\")\nunit = Library.load(ontology_graph=\"http://qudt.org/3.1.1/vocab/unit\")\nquantitykind = Library.load(ontology_graph=\"http://qudt.org/3.1.1/vocab/quantitykind\")\ntemplates = Library.load(directory=\"BuildingMOTIF/libraries/ashrae/223p/nrel-templates\")\n\n# create a Model to hold our building model\nmodel = Model.create(\"urn:example\")\nBLDG = Namespace(\"urn:example/\")\n\n\n\n","type":"content","url":"/model-creation-buildingmotif#setting-up-buildingmotif","position":3},{"hierarchy":{"lvl1":"Creating a Model with BuildingMOTIF","lvl2":"Building the Model"},"type":"lvl2","url":"/model-creation-buildingmotif#building-the-model","position":4},{"hierarchy":{"lvl1":"Creating a Model with BuildingMOTIF","lvl2":"Building the Model"},"content":"Now, we load the templates into a ModelBuilder context, which allows us to use the templates to create our model.\n\nbuilder = ModelBuilder(BLDG)\nbuilder.add_templates_from_library(templates)\n\n\n\nWe will create a reheat VAV terminal unit serving a physical space\n\n# Create a VAV terminal unit with reheat\nvav = builder[\"vav-reheat\"](name=\"my_vav\")\n# we can give names to the sensors inside the VAV\nvav[\"sup-air-temp-sensor\"] = \"BLDG_VAV:SAT\"\nvav[\"sup-air-flow-sensor\"] = \"BLDG_VAV:SAF\"\n\n# create the physical space\nzone = builder[\"hvac-space\"](name=\"my_zone\")\n\n# connect the VAV terminal unit to the zone using a duct\nduct2zone = builder[\"duct\"](a=vav['air-out'], b=zone['in'], name=\"duct2zone\")\n\n\n\nWhen we are done, compile the “builder” into the model\n\nmodel.add_graph(builder.compile())\nprint(f\"Model has {len(model.graph)} triples\")\n\n\n\n\n\nThe model is now ready and contains the VAV terminal unit and the physical space it serves:\n\n223P model generated from templates\n\nprint(model.graph.serialize())\n\n","type":"content","url":"/model-creation-buildingmotif#building-the-model","position":5},{"hierarchy":{"lvl1":"Creating a Model with BuildingMOTIF","lvl2":"Compiling the Model"},"type":"lvl2","url":"/model-creation-buildingmotif#compiling-the-model","position":6},{"hierarchy":{"lvl1":"Creating a Model with BuildingMOTIF","lvl2":"Compiling the Model"},"content":"The generated model is the “pre-inference” model, as described in \n\nModel Inference.\nTo apply inference rules to this model, we will need to load the 223P ontology and apply the inference rules as described in that document.\n\ncompiled_model = model.compile([s223.get_shape_collection(), unit.get_shape_collection(), quantitykind.get_shape_collection()])\nprint(f\"Compiled model has {len(compiled_model.graph)} triples\")\n\n\n\n223P model with all inferred triples\n\nprint(compiled_model.graph.serialize())\n\n","type":"content","url":"/model-creation-buildingmotif#compiling-the-model","position":7},{"hierarchy":{"lvl1":"Model Exploration"},"type":"lvl1","url":"/model-exploration","position":0},{"hierarchy":{"lvl1":"Model Exploration"},"content":"Note\n\nThe purpose of this tutorial is to explore a model by learning the following:\n\nParsing (loading) an existing model\n\nQuerying an existing model.\n\nFor this tutorial, we’ll use an existing equipment model of a variable air volume (VAV) terminal unit with cooling only from section 4.1 of ASHRAE Guideline 36-2021. This and other example models are available from \n\nOpen223 Models.","type":"content","url":"/model-exploration","position":1},{"hierarchy":{"lvl1":"Model Exploration","lvl2":"Model Parsing"},"type":"lvl2","url":"/model-exploration#model-parsing","position":2},{"hierarchy":{"lvl1":"Model Exploration","lvl2":"Model Parsing"},"content":"First, we’ll create a new empty graph then parse (load) an existing graph into it using the Python RDFLib library.\n\nfrom rdflib import Graph\n\n# Create a Graph\ng = Graph()\n\n# Parse in an RDF file hosted on the Internet\ng.parse(\"https://models.open223.info/guideline36-2021-A-1.ttl\", format=\"ttl\")\n\n\n\nNext, we’ll explore the model’s size by printing the number of triples in it.\n\n# Print the number of \"triples\" in the Graph\nprint(f\"Graph g has {len(g)} statements.\")\n\n\n\nFinally, we’ll print the contents of the model since it’s not that large.\n\n# Print out the entire Graph in the RDF Turtle format\nprint(g.serialize(format=\"turtle\"))\n\n\n\n","type":"content","url":"/model-exploration#model-parsing","position":3},{"hierarchy":{"lvl1":"Model Exploration","lvl2":"Model Querying"},"type":"lvl2","url":"/model-exploration#model-querying","position":4},{"hierarchy":{"lvl1":"Model Exploration","lvl2":"Model Querying"},"content":"After exploring the model to get a sense for what it contains, let’s query the model using RDFLib (this can also be done with \n\nOpen223 Query). For this tutorial, we’ll query the model for all the VAV terminal’s points, which are instances of the following classes:\n\nOpen223 Explore links:\n\nQuantifiableActuatableProperty\n\nQuantifiableObservableProperty\n\n# Query the data in g using SPARQL\nq = \"\"\"\nPREFIX s223: <http://data.ashrae.org/standard223#>\n\nSELECT ?obj WHERE {\n  { ?obj a s223:QuantifiableActuatableProperty . }\n  \tUNION\n  { ?obj a s223:QuantifiableObservableProperty . }\n}\n\"\"\"\n\n# Apply the query to the graph and iterate through results\nfor r in g.query(q):\n    print(r)\n\n","type":"content","url":"/model-exploration#model-querying","position":5},{"hierarchy":{"lvl1":"Model Inference"},"type":"lvl1","url":"/model-inference","position":0},{"hierarchy":{"lvl1":"Model Inference"},"content":"Note\n\nThe purpose of this tutorial is to show how SHACL inference applied to a 223 model can\nmake models easier to write and query. Specifically, this tutorial will teach the following:\n\nHow to load SHACL inference rules defined in the 223 ontology into memory\n\nHow to apply SHACL inference rules to a 223 model to add all “implied” triples\n\nFor this tutorial, we’ll use an existing equipment model of a variable air volume (VAV) terminal unit with cooling only from section 4.1 of ASHRAE Guideline 36-2021.\nThis and other example models are available from \n\nOpen223 Models.","type":"content","url":"/model-inference","position":1},{"hierarchy":{"lvl1":"Model Inference","lvl2":"What are SHACL Rules?"},"type":"lvl2","url":"/model-inference#what-are-shacl-rules","position":2},{"hierarchy":{"lvl1":"Model Inference","lvl2":"What are SHACL Rules?"},"content":"SHACL rules add implied information to graphs if certain conditions are met, i.e. if certain triples exist in the source graph.\nThe process of applying rules to an input model to generate new information (triples) is called inference.\nInference makes models easier to write because the model author does not have to manually include all the triples necessary to support the desired queries;\ninstead, some of those useful triples can be added “automatically” to the model through the use of inferencing.\nOne way to think of inference is a way of normalizing a 223 model.\nInference assures that the expected properties, types, and other annotations are present so that consumers of the model can make assumptions about what information will be contained within the graph.","type":"content","url":"/model-inference#what-are-shacl-rules","position":3},{"hierarchy":{"lvl1":"Model Inference","lvl2":"Model Parsing"},"type":"lvl2","url":"/model-inference#model-parsing","position":4},{"hierarchy":{"lvl1":"Model Inference","lvl2":"Model Parsing"},"content":"First, we’ll create a new empty graph then parse (load) an existing graph into it using the Python RDFLib library.\n\nfrom rdflib import Graph\n# Create a Graph\nmodel = Graph()\n# Parse in an RDF file hosted on the Internet\nmodel.parse(\"https://models.open223.info/guideline36-2021-A-1.ttl\", format=\"ttl\")\nprint(f\"The model contains {len(model)} triples\")\n\n\n\nTurtle representation of the model (pre-inference)\n\nprint(model.serialize())\n\n","type":"content","url":"/model-inference#model-parsing","position":5},{"hierarchy":{"lvl1":"Model Inference","lvl3":"Testing the Model (Failed Query)","lvl2":"Model Parsing"},"type":"lvl3","url":"/model-inference#testing-the-model-failed-query","position":6},{"hierarchy":{"lvl1":"Model Inference","lvl3":"Testing the Model (Failed Query)","lvl2":"Model Parsing"},"content":"Below, we try to run a simple query on our model which asks what the terminal unit is connected to.\nThe s223:connected relationship does not exist in the pre-inference model, so this query will not return results.\n\nparts_query = \"\"\"\nPREFIX bldg: <http://data.ashrae.org/standard223/1.0/data/guideline36-2021-A-1#>\nPREFIX s223: <http://data.ashrae.org/standard223#>\nSELECT ?physical_space WHERE {\n    bldg:VAVCoolingOnly s223:connected ?physical_space .\n}\"\"\"\n\nfor row in model.query(parts_query):\n    print('\\t'.join(row))\n\n\n\n","type":"content","url":"/model-inference#testing-the-model-failed-query","position":7},{"hierarchy":{"lvl1":"Model Inference","lvl2":"Loading the 223 Ontology"},"type":"lvl2","url":"/model-inference#loading-the-223-ontology","position":8},{"hierarchy":{"lvl1":"Model Inference","lvl2":"Loading the 223 Ontology"},"content":"The 223 ontology contains the rules we will use for inference.\nWe will load the 223 ontology into a separate graph from the model.\nThis is mostly for maintenance: it is easy enough to merge two graphs together into one, but it is much harder to factor them out again.\nBy keeping the ontology graph separate from the model graph, we can more easily maintain and version those graphs individually.\n\nfrom rdflib import Graph\n# Create a Graph\ns223 = Graph()\n# Parse in a recent copy of the 223 ontology\ns223.parse(\"https://query.open223.info/ontologies/223p.ttl\")\n\n\n\n","type":"content","url":"/model-inference#loading-the-223-ontology","position":9},{"hierarchy":{"lvl1":"Model Inference","lvl2":"Applying Inference Rules"},"type":"lvl2","url":"/model-inference#applying-inference-rules","position":10},{"hierarchy":{"lvl1":"Model Inference","lvl2":"Applying Inference Rules"},"content":"To apply inference rules, we need an inference engine.\nThis is a piece of software which knows how to properly interpret and apply the SHACL rules defined in an ontology.\nThere are multiple closed-source and open-source implementations of SHACL available; some of these are listed on \n\nthis page\nBelow, we will be using the open-source \n\nPySHACL library.\n\nWe import the PySHACL library and then invoke the validate function on our model graph (data graph in PySHACL parlance)\nand our 223 graph (shape graph in PySHACL parlance).\nWe run this several times to ensure that all the rules are applied.\n\nimport pyshacl\n\ncombined = model+s223\nfor _ in range(3):\n    pyshacl.validate(combined,\n        allow_infos=True,     # don't fail if we get an INFO message\n        allow_warnings=True,  # don't fail if we get a WARNING message\n        abort_on_first=False, # allow errors to happen during execution\n        advanced=True,        # allow SHACL rules to execute\n        iterate_rules=True,  # allow rules to be applied multiple times\n        inplace=True          # update the 'model' object with the inferred triples\n    )\n# remove the s223 graph from the model\nmodel = combined - s223\nprint(f\"The model now contains {len(model)} triples\")\n\n\n\nThis may take a few minutes to run, depending on the size of your model.\nIf the PySHACL library is too slow, we recommend looking at alternate open-source implementations\nlike \n\nTopQuadrant’s Java-based implementation.\n\nWe can see from the print statement that several triples have been added to the model.\n\nNote\n\nThe pyshacl.validate function actually returns a SHACL validation report which can be used to fix\nthe model and make it compatible with the 223 ontology. See the \n\nModel Validation\ntutorial for how to access and interpret this report.\n\nTurtle representation of the model (post-inference)\n\nprint(model.serialize())\n\n","type":"content","url":"/model-inference#applying-inference-rules","position":11},{"hierarchy":{"lvl1":"Model Inference","lvl2":"Using the New Model"},"type":"lvl2","url":"/model-inference#using-the-new-model","position":12},{"hierarchy":{"lvl1":"Model Inference","lvl2":"Using the New Model"},"content":"To demonstrate that the model contains new triples, we can try re-running the query from before.\nWe can see that the query returns results this time.\n\nquery = \"\"\"\nPREFIX bldg: <http://data.ashrae.org/standard223/1.0/data/guideline36-2021-A-1#>\nPREFIX s223: <http://data.ashrae.org/standard223#>\nSELECT ?physical_space WHERE {\n    bldg:VAVCoolingOnly s223:connected ?physical_space .\n}\"\"\"\n\nfor row in model.query(query):\n    print('\\t'.join(row))\n\n","type":"content","url":"/model-inference#using-the-new-model","position":13}]}